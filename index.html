<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ARC Raiders Blueprint Importer</title>

  <style>
    :root{
      --bg:#1f1f1f;
      --panel:#262626;
      --panel2:#2c2c2c;
      --text:#eaeaea;
      --muted:#b7b7b7;
      --border:#3a3a3a;
      --accent:#7aa7ff;
    }
    body {
      font-family: system-ui, sans-serif;
      max-width: 920px;
      margin: 40px auto;
      padding: 0 16px;
      background: var(--bg);
      color: var(--text);
    }
    h2 { margin-bottom: 6px; }
    .row { margin: 12px 0; }
    label { display:block; font-weight:600; margin-bottom:6px; color: var(--text); }
    input[type="text"], textarea, select {
      width:100%;
      padding:10px;
      font-size:16px;
      box-sizing:border-box;
      color: var(--text);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      outline: none;
    }
    input[type="text"]:focus, textarea:focus, select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(122,167,255,.15);
    }
    textarea {
      min-height:220px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    }
    button {
      padding:10px 14px;
      font-size:16px;
      cursor:pointer;
      margin-right:8px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel2);
      color: var(--text);
    }
    button:hover { border-color: #4b4b4b; }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .muted { color: var(--muted); font-size:14px; }
    .preview { max-width:100%; border-radius:12px; border:1px solid var(--border); margin-top:8px; }
    .status {
      white-space:pre-wrap;
      background: var(--panel);
      padding:12px;
      border-radius:10px;
      border: 1px solid var(--border);
    }
    .progressWrap {
      margin-top:10px;
      background: #303030;
      border-radius:999px;
      overflow:hidden;
      height:14px;
      border: 1px solid var(--border);
    }
    .progressBar { height:14px; width:0%; background: var(--accent); transition: width 120ms linear; }
    .logBox {
      margin-top:10px;
      padding:10px;
      border:1px solid var(--border);
      border-radius:10px;
      background: #1a1a1a;
      max-height:240px;
      overflow:auto;
      font-family: ui-monospace, monospace;
      font-size:12px;
      white-space:pre-wrap;
      color: #d6d6d6;
    }
    .toggle { display:inline-flex; gap:8px; align-items:center; user-select:none; margin-top:10px; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 780px) { .grid2 { grid-template-columns: 1fr; } }
    code { background:#111; padding:2px 6px; border-radius:6px; border:1px solid var(--border); }
    .pill { display:inline-block; padding:2px 10px; border-radius:999px; background:#111; border:1px solid var(--border); font-size:12px; margin-left:8px; color: var(--muted); }
  </style>

  <!-- Pin v5 library -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
</head>

<body>
  <h2>ARC Raiders “Needed Blueprints” → Google Sheets</h2>
  <div class="muted">OCR runs locally in your browser (Worker + WASM). Then the list is posted to your Google Sheet via Apps Script.</div>

  <div class="row">
    <div class="muted">Backend: <code id="apiLabel"></code></div>
  </div>

  <div class="row grid2">
    <div>
      <label>MetaForge username (required)</label>
      <input id="username" type="text" placeholder="e.g. frommlet" />
    </div>
    <div>
      <label>OCR asset mode <span class="pill" id="assetHint">LOCAL (/tess)</span></label>
      <select id="assetMode">
        <option value="local" selected>Use this site’s /tess/ assets</option>
        <option value="cdn">Use pinned CDN assets</option>
      </select>
      <div class="muted">If LOCAL fails, the app will auto-retry with CDN.</div>
    </div>
  </div>

  <div class="row">
    <label>Optional shared key</label>
    <input id="secret" type="text" placeholder="only if you set SHARED_SECRET in Code.gs" />
  </div>

  <div class="row">
    <label>Upload “Needed Blueprints” image</label>
    <input id="file" type="file" accept="image/*" />
    <img id="imgPreview" class="preview" style="display:none;" />
  </div>

  <div class="row">
    <button id="extractBtn" disabled>1) Extract</button>
    <button id="sendBtn" disabled>2) Send to Sheet</button>

    <label class="toggle">
      <input id="verbose" type="checkbox" checked /> Verbose logs
    </label>

    <div id="progressArea" style="display:none;">
      <div class="progressWrap"><div id="progressBar" class="progressBar"></div></div>
      <div class="muted"><strong>Stage:</strong> <span id="stage">—</span> | <strong>Progress:</strong> <span id="pct">0%</span></div>
      <div id="logBox" class="logBox" style="display:none;"></div>
    </div>
  </div>

  <div class="row">
    <label>Extracted blueprint names (one per line)</label>
    <textarea id="list" placeholder="Run extraction first…"></textarea>
    <div class="muted">Tip: fix OCR mistakes here before sending.</div>
  </div>

  <div class="row status" id="status">Status: waiting…</div>

<script>
  // ✅ baked-in Apps Script endpoint (no textbox)
  const API_URL = "https://script.google.com/macros/s/AKfycbxUWZEmHM26jUNhvKrRqL1qJt1HN5dOfvK6xz6F940lVWBCQeDxQAqCW87EoxsM9jPqyg/exec";

  const els = {
    apiLabel: document.getElementById('apiLabel'),
    username: document.getElementById('username'),
    secret: document.getElementById('secret'),
    file: document.getElementById('file'),
    preview: document.getElementById('imgPreview'),
    extractBtn: document.getElementById('extractBtn'),
    sendBtn: document.getElementById('sendBtn'),
    list: document.getElementById('list'),
    status: document.getElementById('status'),
    verbose: document.getElementById('verbose'),
    progressArea: document.getElementById('progressArea'),
    progressBar: document.getElementById('progressBar'),
    stage: document.getElementById('stage'),
    pct: document.getElementById('pct'),
    logBox: document.getElementById('logBox'),
    assetMode: document.getElementById('assetMode'),
    assetHint: document.getElementById('assetHint'),
  };

  els.apiLabel.textContent = API_URL;

  // persist username + asset mode
  const LS_USER = "bpImporter_username";
  const LS_MODE = "bpImporter_assetMode";
  els.username.value = localStorage.getItem(LS_USER) || "";
  els.assetMode.value = localStorage.getItem(LS_MODE) || "local";

  function setAssetHint() {
    els.assetHint.textContent = (els.assetMode.value === "local") ? "LOCAL (/tess)" : "CDN";
  }
  setAssetHint();

  els.username.addEventListener("input", () => {
    localStorage.setItem(LS_USER, els.username.value);
    updateButtons();
  });

  els.assetMode.addEventListener("change", () => {
    localStorage.setItem(LS_MODE, els.assetMode.value);
    setAssetHint();
  });

  let loadedImage = null;

  function setStatus(msg){ els.status.textContent = "Status: " + msg; }
  function setStage(s){ els.stage.textContent = s; }
  function setProgress(p){
    const c = Math.max(0, Math.min(1, p));
    const pct = Math.round(c * 100);
    els.pct.textContent = pct + "%";
    els.progressBar.style.width = pct + "%";
  }
  function log(line){
    if (!els.verbose.checked) return;
    els.logBox.style.display = 'block';
    els.logBox.textContent += line + "\n";
    els.logBox.scrollTop = els.logBox.scrollHeight;
  }
  els.verbose.addEventListener('change', ()=> {
    els.logBox.style.display = els.verbose.checked ? 'block' : 'none';
  });

  function updateButtons() {
    const ok = !!els.username.value.trim() && !!loadedImage;
    els.extractBtn.disabled = !ok;
    els.sendBtn.disabled = !els.list.value.trim() || !els.username.value.trim();
  }
  els.list.addEventListener('input', updateButtons);

  els.file.addEventListener('change', () => {
    const file = els.file.files[0];
    if (!file) return;

    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      loadedImage = img;
      els.preview.src = url;
      els.preview.style.display = 'block';
      els.list.value = '';
      setStatus("Image loaded.");
      updateButtons();
    };
    img.onerror = () => setStatus("Failed to load image.");
    img.src = url;
  });

  async function withTimeout(promise, ms, msg) {
    let t;
    const timeout = new Promise((_, rej) => t = setTimeout(() => rej(new Error(msg)), ms));
    const res = await Promise.race([promise, timeout]);
    clearTimeout(t);
    return res;
  }

  // Fetch and also detect "HTML masquerading as JS" (the cause of your '<' error)
  async function assertNotHtml(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    const ct = (res.headers.get("content-type") || "").toLowerCase();
    // Some hosts don't set perfect types; do a cheap body sniff for HTML on JS files
    if (url.endsWith(".js")) {
      const head = (await res.text()).slice(0, 40).trim();
      if (head.startsWith("<") || ct.includes("text/html")) {
        throw new Error(`Got HTML instead of JS for ${url} (this causes "Unexpected token <")`);
      }
    }
  }

  function getAssetConfig(mode) {
    if (mode === "cdn") {
      return {
        label: "CDN",
        workerPath: "https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/worker.min.js",
        corePath:   "https://cdn.jsdelivr.net/npm/tesseract.js-core@5.1.0/",
        langPath:   "https://tessdata.projectnaptha.com/4.0.0/",
      };
    }
    const base = new URL('.', window.location.href).toString(); // ends with /
    return {
      label: "LOCAL",
      workerPath: base + "tess/worker.min.js",
      corePath:   base + "tess/core/",
      langPath:   base + "tess/lang/",
    };
  }

  async function preflightAllCoreVariants(cfg) {
    log(`[paths] mode=${cfg.label}`);
    log(`[paths] workerPath: ${cfg.workerPath}`);
    log(`[paths] corePath:   ${cfg.corePath}`);
    log(`[paths] langPath:   ${cfg.langPath}`);

    setStage("Preflight"); setProgress(0.03);
    await assertNotHtml(cfg.workerPath);

    // IMPORTANT: check all core wrapper JS files because Chrome may choose SIMD/LSTM
    const coreJs = [
      "tesseract-core.wasm.js",
      "tesseract-core-simd.wasm.js",
      "tesseract-core-lstm.wasm.js",
      "tesseract-core-simd-lstm.wasm.js",
    ];

    let i = 0;
    for (const f of coreJs) {
      setStage("Preflight (core wrappers)"); setProgress(0.04 + (i / coreJs.length) * 0.03);
      await assertNotHtml(cfg.corePath + f);
      i++;
    }

    // Also ensure the wasm payloads exist (no HTML check needed here)
    const coreWasm = [
      "tesseract-core.wasm",
      "tesseract-core-simd.wasm",
      "tesseract-core-lstm.wasm",
      "tesseract-core-simd-lstm.wasm",
    ];
    for (const f of coreWasm) {
      const res = await fetch(cfg.corePath + f, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${cfg.corePath + f}`);
    }

    // language
    const langRes = await fetch(cfg.langPath + "eng.traineddata.gz", { cache: "no-store" });
    if (!langRes.ok) throw new Error(`HTTP ${langRes.status} for ${cfg.langPath}eng.traineddata.gz`);

    log("[preflight] assets OK");
  }

  function preprocessToCanvas(img) {
    const srcW = img.naturalWidth || img.width;
    const srcH = img.naturalHeight || img.height;

    const MAX_W = 1800;
    const scale = Math.min(1, MAX_W / srcW);
    const w = Math.round(srcW * scale);
    const h = Math.round(srcH * scale);

    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    ctx.drawImage(img, 0, 0, w, h);

    const imageData = ctx.getImageData(0, 0, w, h);
    const d = imageData.data;
    const threshold = 135;

    for (let i = 0; i < d.length; i += 4) {
      const r = d[i], g = d[i+1], b = d[i+2];
      const lum = 0.2126*r + 0.7152*g + 0.0722*b;
      const v = (lum > threshold) ? 255 : 0;
      d[i] = d[i+1] = d[i+2] = v;
      d[i+3] = 255;
    }
    ctx.putImageData(imageData, 0, 0);
    log(`[preprocess] ${srcW}x${srcH} → ${w}x${h}`);
    return canvas;
  }

  function titleCaseWord(w){ return w ? (w[0].toUpperCase() + w.slice(1).toLowerCase()) : w; }

  function parseBlueprintLines(rawText) {
    const lines = rawText.split('\n').map(s=>s.trim()).filter(Boolean);

    const filtered = [];
    for (const line of lines) {
      if (/^metaforge$/i.test(line)) continue;
      if (/^needed\s+blueprints\s*:\s*\d+/i.test(line)) continue;
      filtered.push(line);
    }

    const out = [];
    for (let i=0; i<filtered.length; i++) {
      const cur = filtered[i];
      const next = filtered[i+1];

      if (/^(flanking|aggressive)$/i.test(cur) && next && /^combat\s+mk\.?\s*3$/i.test(next)) {
        out.push(`${next.replace(/\s+/g,' ').trim()} (${titleCaseWord(cur)})`); i++; continue;
      }
      if (/^not[-\s]?in[-\s]?game$/i.test(cur) && next && next.length <= 16) {
        out.push(`not-in-game ${next}`); i++; continue;
      }
      if (next && /^(?:I|II|III|IV|V|VI|VII|VIII|IX|X)$/i.test(next) &&
          !/^(?:I|II|III|IV|V|VI|VII|VIII|IX|X)$/i.test(cur)) {
        out.push(`${cur} ${next.toUpperCase()}`); i++; continue;
      }
      if (next && /^[A-Za-z]{1,2}$/.test(next) && cur.length >= 3) {
        out.push(`${cur} ${next}`); i++; continue;
      }
      if (/^(?:I|II|III|IV|V|VI|VII|VIII|IX|X)$/i.test(cur)) continue;

      out.push(cur);
    }

    const seen = new Set();
    const final = [];
    for (const n of out) {
      const s = n.trim().replace(/\s+/g,' ');
      const k = s.toLowerCase();
      if (!s || seen.has(k)) continue;
      seen.add(k);
      final.push(s);
    }
    return final;
  }

  async function runOcrOnce(mode) {
    const cfg = getAssetConfig(mode);
    await preflightAllCoreVariants(cfg);

    setStage("Preprocessing"); setProgress(0.10);
    setStatus("Preprocessing image…");
    const canvas = preprocessToCanvas(loadedImage);

    setStage("Creating worker"); setProgress(0.12);
    setStatus("Starting OCR engine…");

    // ✅ v5 API: createWorker(lang, oem, options)
    const worker = await withTimeout(
      Tesseract.createWorker("eng", 1, {
        workerPath: cfg.workerPath,
        corePath: cfg.corePath,
        langPath: cfg.langPath,
        logger: (m) => {
          const stage = m.status || "working";
          const prog = (typeof m.progress === "number") ? m.progress : 0;
          setStage(stage);
          setProgress(0.12 + 0.83 * prog);
          log(`[${stage}] ${Math.round(prog*100)}%`);
        },
      }),
      45000,
      "Worker start timed out."
    );

    try {
      await worker.setParameters({
        tessedit_char_whitelist: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 -().:_",
      });

      setStage("Recognizing"); setStatus("Running OCR…");
      const { data } = await worker.recognize(canvas);

      setStage("Parsing"); setProgress(0.98);
      const names = parseBlueprintLines(data?.text || "");
      els.list.value = names.join("\n");
      updateButtons();

      setStage("Done"); setProgress(1.0);
      setStatus(`Extracted ${names.length} items. Review/edit, then Send.`);
    } finally {
      await worker.terminate();
    }
  }

  els.extractBtn.addEventListener('click', async () => {
    els.logBox.textContent = '';
    els.progressArea.style.display = 'block';
    els.logBox.style.display = els.verbose.checked ? 'block' : 'none';

    const username = els.username.value.trim();
    if (!username) { setStatus("Username is required."); return; }
    if (!loadedImage) { setStatus("Please upload an image."); return; }

    const preferred = els.assetMode.value;

    try {
      await runOcrOnce(preferred);
    } catch (e) {
      const msg = e?.message || String(e);
      log("[error] " + (e?.stack || msg));

      // Auto-fallback: the '<' error means HTML came back for a JS import
      const looksLikeHtmlImport = /Unexpected token\s*'</i.test(msg) || /importScripts/i.test(msg) || /Got HTML instead of JS/i.test(msg);

      if (preferred === "local" && looksLikeHtmlImport) {
        log("");
        log("LOCAL mode core import returned HTML. Auto-retrying with CDN…");
        setStatus("LOCAL assets failed (HTML returned for core). Retrying with CDN…");
        els.assetMode.value = "cdn";
        setAssetHint();

        try {
          await runOcrOnce("cdn");
          return;
        } catch (e2) {
          const msg2 = e2?.message || String(e2);
          setStatus("OCR failed (CDN also failed): " + msg2);
          log("[error] " + (e2?.stack || msg2));
          return;
        }
      }

      setStatus("OCR failed: " + msg);
    }
  });

  els.sendBtn.addEventListener('click', async () => {
    const username = els.username.value.trim();
    const secret = els.secret.value;

    if (!username) { setStatus("Username is required."); return; }

    const blueprints = els.list.value.split("\n").map(s=>s.trim()).filter(Boolean);
    if (!blueprints.length) { setStatus("Nothing to send."); return; }

    setStatus("Sending to Google Sheet…");

    try {
      const res = await fetch(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, blueprints, secret }),
      });

      const json = await res.json().catch(() => ({}));
      if (!json.ok) {
        setStatus("Import failed: " + (json.error || ("HTTP " + res.status)));
        return;
      }
      setStatus(`Done! Tab: ${json.tabName} | Wrote ${json.count} rows (overwritten).`);
    } catch (e) {
      setStatus("Import failed: " + (e?.message || String(e)));
    }
  });

  // initial state
  updateButtons();
</script>
</body>
</html>
